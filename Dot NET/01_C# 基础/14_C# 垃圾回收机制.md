# 垃圾回收

## 1.垃圾回收涉及概念

### 1.1 内存管理

> 内存管理是指用户为变量在堆上分配内存后，谁来管理以及怎么管理释放问题。

* C++、C 程序员手动管理  。
* C#、Java、Python、JS 语言运行时自动管理。

### 1.2 托管资源

> 托管资源式 .NET 平台 CLR 提供的内存管理方式，由 .NET 负责内存生成以及释放。
>
> 主要有：
>
> * 栈资源—根据函数运行自动分配释放
> * 托管堆—用户需要的时候 new 出，不需要会自动释放

### 1.3 非托管资源

> CLR 系统只能跟踪其声明周期，而不能决定如何释放资源，如数据库连接、文件句柄以及指针结果等。

## 2. 垃圾回收

> 垃圾回收即通过一定算法，得到内存中哪些对象需要被回收，并在GC阶段将垃圾对象的回收过程。
>
> 逻辑：
>
> 从程序的根对象 root 开始，层层遍历在堆上分配的对象，不再被引用到的对象即判定为垃圾。可被引用到的对象称为Rachable Object;
>
> Root 对象有如下四种：
>
> * 全局对象
> * 静态变量
> * 栈上现存变量
> * CPU 寄存器中的变量

## 3. 垃圾回收算法

### 3.1 Mark-Compac 标记压缩算法

> C# 采用的是该算法，具体分为两个阶段，即 `Mark` 标记 与 `Compact` 压缩

![垃圾回收机制](./assets/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.png)

* 阶段1：标记清除阶段(Mark-Sweep)

    ①最初设定所有对象都不可到达 Unreachable (即没有引用，可以回收）；

    ②从程序各个根对象开始查找，找出有引用的对象，标记为可到达的 Reachable 即要用的不可清除。

    ③清除所有 Unreachable 不可到达的垃圾对象。

* 阶段2：压缩阶段(Compact)

    ① 因为经过清除阶段，清除了各种无用对象后，剩余的有用对象存放位置可能就不连续了。

    为了更好的腾出可使用空间，会将剩余的有用对象在堆中压缩，使其地址紧凑连续分布。

    ② 引用地址修复：压缩会修改堆中对象的存放地址，所以得修复引用对象在栈中的引用、CPU寄存器变量引用以及堆中引用。

## 4. GC 触发逻辑

> 一个运行起来的程序，可能会有几百M到几G的内存，全部扫描并且压缩会有巨大的操作成本;

### 4.1 分代算法（Generational）

> 分代算法具有一定的统计学基础，即根据程序运行的统计分布规律得出结果。

**分代算法基于的常识：**

> 1、大量新创建的对象生命周期都比较短、而较老对象声明周期则一般较长。
>
> 2、对部分内存进行垃圾处理，相比对于整个程序进行全部垃圾处理操作要快。

**分带算法逻辑**

* ①将对象分为三个年龄阶段：幼年代(或新生代)(gen0)、青年代(gen1)、老年代(gen2)。
* ②程序启动时，在程序内存中分别划分出存储这三种类型对象的区域，并给出预算（Budget）大小容量。幼年代区最小、老年代区最大。各个代区内存超范围预算返回时，就执行GC。
* ③最开始创建的对象都为新生代，存储在新生代区。
* ④当执行了GC之后，新生代区容量不足，无法继续存储新生代对象时，原来在新生代区经历过GC且仍然有用的对象就会被升级为青年代、移动存放到青年代内存区存放。
* ⑤以此类推，当执行了GC之后，青年代区容量也不足之后，原来在青年代区经历过GC且让然有用的对象，就会被升级为老年代，移动存放到老年代内存区。
* 根据容量大小，以及平台GC规则，不同代区的执行频率也会不同，这样就不用每次都对所有对象执行GC，可以实现分区执行。